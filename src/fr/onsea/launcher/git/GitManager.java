// Generated by delombok at Sat Feb 25 08:55:47 CET 2023
/**
*	Copyright 2021-2023 Onsea Studio All rights reserved.
*
*	This file is part of Onsiea Engine. (https://github.com/Onsea Studio/Onsea StudioEngine)
*
*	Unless noted in license (https://github.com/Onsea Studio/Onsea StudioEngine/blob/main/LICENSE.md) notice file (https://github.com/Onsea Studio/Onsea StudioEngine/blob/main/LICENSE_NOTICE.md), Onsea Studio engine and all parts herein is licensed under the terms of the LGPL-3.0 (https://www.gnu.org/licenses/lgpl-3.0.html)  found here https://www.gnu.org/licenses/lgpl-3.0.html and copied below the license file.
*
*	Onsiea Engine is libre software: you can redistribute it and/or modify
*	it under the terms of the GNU Lesser General Public License as published by
*	the Free Software Foundation, either version 3.0 of the License, or
*	(at your option) any later version.
*
*	Onsiea Engine is distributed in the hope that it will be useful,
*	but WITHOUT ANY WARRANTY; without even the implied warranty of
*	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*	GNU Lesser General Public License for more details.
*
*	You should have received a copy of the GNU Lesser General Public License
*	along with Onsiea Engine.  If not, see <https://www.gnu.org/licenses/> <https://www.gnu.org/licenses/lgpl-3.0.html>.
*
*	Neither the name "Onsea Studio", "Onsiea Engine", or any derivative name or the names of its authors / contributors may be used to endorse or promote products derived from this software and even less to name another project or other work without clear and precise permissions written in advance.
*
*	(more details on https://github.com/OnseaStudio/OnsieaEngine/wiki/License)
*
*	@author Seynax
*/
package fr.onsea.launcher.git;

import java.io.File;
import java.io.IOException;
import java.util.Collection;

import org.eclipse.jgit.api.Git;
import org.eclipse.jgit.api.PullResult;
import org.eclipse.jgit.lib.AnyObjectId;
import org.eclipse.jgit.lib.ProgressMonitor;
import org.eclipse.jgit.lib.Repository;
import org.eclipse.jgit.storage.file.FileRepositoryBuilder;

import fr.onsea.launcher.utils.Pair;
import lombok.Getter;

/**
 * @Organization Onsea
 * @author Seynax
 */
public class GitManager
{
	private static final boolean				PULL_AFTER_CLONING	= false;
	private static final boolean				WITH_MONITORING		= true;
	private static final Callback				CALLBACK			= new Callback();
	private static final SimpleProgressMonitor	MONITOR				= new SimpleProgressMonitor();

	/**
	 * Attempts to retrieve local repository from pathIn<br>
	 * if boss does not end with "/.git" this term is added
	 * @param pathIn
	 * @return
	 * @throws IOException
	 */
	public static final Repository local(final String pathIn) throws IOException
	{
		return GitManager.local(pathIn, false);
	}

	/**
	 * Attempts to retrieve local repository from pathIn<br>
	 * if boss does not end with "/.git" this term is added<br>
	 * mustIfExist is defined from mustIfExistIn
	 * @param pathIn
	 * @return
	 * @throws IOException
	 */
	public static final Repository local(final String pathIn, final boolean mustExistIn) throws IOException
	{
		var path = pathIn;
		if (!pathIn.endsWith("/.git"))
		{
			path += "/.git";
		}
		if (GitManager.WITH_MONITORING)
		{
			System.out.println("Tries to get local repository from \"" + pathIn + "\"");
		}
		return new FileRepositoryBuilder().setMustExist(mustExistIn).setGitDir(new File(path)).build();
	}

	/**
	 * This method attempts to clone from the branch branchNameIn of the remote repository urlIn into the directory localDirectoryFileIn,<br>
	 * if the directory does not exist it is created.
	 * @param urlIn
	 * @param branchNameIn
	 * @param localDirectoryFileIn
	 * @return
	 * @throws Exception
	 */
	public static final Git cloneContent(final String urlIn, final String branchNameIn, final File localDirectoryFileIn)
			throws Exception
	{
		if (!localDirectoryFileIn.exists())
		{
			if (GitManager.WITH_MONITORING)
			{
				System.out.println("\"" + localDirectoryFileIn.getAbsolutePath()
						+ "\" directory does not exist, try to create it");
			}
			localDirectoryFileIn.mkdirs();
		}
		final var cloneCommand = Git.cloneRepository().setURI(urlIn).setBranch(branchNameIn);
		if (GitManager.WITH_MONITORING)
		{
			System.out.println("Attempts to clone the branch \"" + branchNameIn + "\" from repository \"" + urlIn
					+ "\" into \"" + localDirectoryFileIn.getAbsolutePath() + "\"");
			cloneCommand.setCallback(GitManager.CALLBACK).setProgressMonitor(GitManager.MONITOR);
		}
		return cloneCommand.setDirectory(localDirectoryFileIn).call();
	}

	public static final PullResult pull(final Git gitIn) throws Exception
	{
		final var lastPullCommand = gitIn.pull();
		if (GitManager.WITH_MONITORING)
		{
			lastPullCommand.setProgressMonitor(new SimpleProgressMonitor());
			System.out.println("Attempts to pull from \"" + gitIn.getRepository().getDirectory() + "\"");
		}
		final var pullResult = lastPullCommand.call();
		if (!pullResult.isSuccessful())
		{
			throw new Exception("[ERROR] GitManager : pull failed \"" + gitIn.getRepository().getDirectory() + "\"");
		}
		return pullResult;
	}

	/**
	 * This method : <br>
	 * - tries to find a local repository from localDirectoryFileIn,<br>
	 * - if it doesn't exist it tries to clone the remote repository from and lastly<br>
	 * @param localDirectoryFileIn
	 * @param urlIn
	 * @param canCreateIn
	 * @return
	 * @throws Exception
	 */
	public static final Pair<Git, PullResult> initRepository(final File localDirectoryFileIn, final String urlIn,
			final String branchNameIn) throws Exception
	{
		final var localRepo = GitManager.local(localDirectoryFileIn.getAbsolutePath());
		if (GitManager.WITH_MONITORING)
		{
			System.out.println("Attempts to init from \"" + localDirectoryFileIn.getAbsolutePath() + "\" with branch \""
					+ branchNameIn + "\" of \"" + urlIn + "\" repository");
		}
		var	pull	= false;
		Git	git		= null;
		if (!localRepo.getObjectDatabase().exists())
		{
			git		= GitManager.cloneContent(urlIn, branchNameIn, localDirectoryFileIn);
			pull	= GitManager.PULL_AFTER_CLONING;
		}
		else
		{
			git		= Git.wrap(localRepo);
			pull	= true;
		}
		PullResult pullResult = null;
		if (pull)
		{
			pullResult = GitManager.pull(git);
		}
		return new Pair<>(git, pullResult);
	}

	private @Getter final String	url;
	private @Getter final File		localDirectoryFile;
	private @Getter final String	branchName;
	private Git						git;
	private @Getter PullResult		lastPullResult;

	public GitManager(final String urlIn, final String directoryIn) throws Exception
	{
		this.url				= urlIn;
		this.localDirectoryFile	= new File(directoryIn);
		this.branchName			= "main";
		final var pair = GitManager.initRepository(this.localDirectoryFile, urlIn, this.branchName);
		this.git			= pair.s1();
		this.lastPullResult	= pair.s2();
	}

	public final GitManager init() throws Exception
	{
		final var pair = GitManager.initRepository(this.localDirectoryFile, this.url, this.branchName);
		this.git			= pair.s1();
		this.lastPullResult	= pair.s2();

		return this;
	}

	public final GitManager cloneContent() throws Exception
	{
		this.git = GitManager.cloneContent(this.url, this.branchName, this.localDirectoryFile);
		return this;
	}

	public final GitManager pull() throws Exception
	{
		GitManager.pull(this.git);
		return this;
	}

	public final GitManager close()
	{
		if (this.git != null)
		{
			this.git.close();
		}
		return this;
	}

	public static final class Callback implements org.eclipse.jgit.api.CloneCommand.Callback
	{
		@Override
		public void initializedSubmodules(final Collection<String> submodulesIn)
		{
			for (final var submodule : submodulesIn)
			{
				System.out.println("Submodule : " + submodule);
			}
		}

		@Override
		public void cloningSubmodule(final String pathIn)
		{
			System.out.println("Clone submodule : " + pathIn);
		}

		@Override
		public void checkingOut(final AnyObjectId commitIn, final String pathIn)
		{
			System.out.println("Checkingout commit name : " + commitIn.getName() + " path : " + pathIn);
		}
	}

	public static final class SimpleProgressMonitor implements ProgressMonitor
	{
		@Override
		public void start(final int totalTasks)
		{
			System.out.println("Starting work on " + totalTasks + " tasks");
		}

		@Override
		public void beginTask(final String title, final int totalWork)
		{
			System.out.println("Start " + title + ": " + totalWork);
		}

		@Override
		public void update(final int completed)
		{
			System.out.print(completed + "-");
		}

		@Override
		public void endTask()
		{
			System.out.println("Done");
		}

		@Override
		public boolean isCancelled()
		{
			return false;
		}
	}
}
